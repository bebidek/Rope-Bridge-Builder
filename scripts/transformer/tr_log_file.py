import capstone as cs
from tr_globals import Node
from tr_asm_elf import disassemble_single_insn

# Log files are generated by Valgrind
# and contain chains: sequences 

def common_prefix(l1: list[int] | None, l2: list[int]) -> list[int]:
    if l1 is None:
        return l2
    for i in range(len(l1)):
        if l1[i] != l2[i]:
            return l1[:i]
    return l1

def load_log_file(log_file_path: str, length_threshold: int, code_sections:dict[str, (int, int, bytearray)]) -> tuple[dict[int,Node], dict[int,cs.CsInsn]]:
    nodes : dict[int, Node] = {}
    insns : dict[int, cs.CsInsn] = {}
    current_node_id, current_chain, current_pre_chain, pre_mode, chain_is_good = None, None, None, None, None # reader state

    with open(log_file_path, 'r') as log_file:
        for line in log_file:
            insn_addr = None
            tokens = line.split()

            if tokens[0] == "SEGMENT": # begining of new segment - initialize reader state
                insn_addr = int(tokens[1], base=0)
                nodes.setdefault(insn_addr, Node(insn_addr))
                current_node_id, current_chain, current_pre_chain, pre_mode, chain_is_good = insn_addr, [], [], True, (tokens[2]=="GOOD")
            
            elif tokens[0] == "CALL": # actual syscall instruction
                pre_mode = False

            elif tokens[0] == "END": # end of segment
                if current_chain[0] != current_node_id + 2:
                    continue # most likely we've captured a signal handler - let's forget about this segment
                elif len(current_chain) > length_threshold:
                    nodes[current_node_id].failed_chains += 1 # chain is too long
                else:
                    assert (insns[current_chain[-1]].mnemonic=='syscall') == chain_is_good # sanity check

                    # save this chain
                    node = nodes[current_node_id]
                    chain = tuple(current_chain)
                    if chain_is_good:
                        node.good_chains.setdefault(chain, 0)
                        node.good_chains[chain] += 1
                    else:
                        node.bad_chains.setdefault(chain, 0)
                        node.bad_chains[chain] += 1

                    node.pre_chain = common_prefix(node.pre_chain, current_pre_chain[::-1])

                    # add node finishing this chain to the structure as well.
                    # it may not have its own chains, but we want it to be legal
                    # and that requires pre_chain
                    # end_node_id = current_chain[-1]
                    # nodes.setdefault(end_node_id, Node(end_node_id))
                    # nodes[end_node_id].pre_chain = common_prefix(nodes[end_node_id].pre_chain, current_chain[-8:-1][::-1])

            else: # we read next instruction of the segment
                insn_addr = int(tokens[0], base=0)
                if pre_mode:
                    current_pre_chain.append(insn_addr)
                else:
                    current_chain.append(insn_addr)
            
            # if encountered new instruction, disassemble it
            if insn_addr is not None and insn_addr not in insns:
                insns[insn_addr] = disassemble_single_insn(code_sections, insn_addr)

    return nodes, insns
